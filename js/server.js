// Generated by CoffeeScript 1.3.3
(function() {
  var addVelocity, asteroids, breakAsteroid, clientCallback, clientDied, clients, collisionDetection, eachFrame, fs, handleControls, http, io, isColliding, mapSize, newAsteroid, radsToDegrees, server, serverCallback, socket, stayOnMap, tickRate, updateAsteroids, updatePhysics, updateStats;

  http = require("http");

  fs = require("fs");

  io = require("socket.io");

  clients = [];

  tickRate = 30;

  mapSize = {
    width: 1280,
    height: 1280
  };

  asteroids = [];

  serverCallback = function(req, res) {
    if (req.url === "/favicon.ico") {
      res.writeHead(200);
      res.end();
      return;
      if (req.url.match(/png/)) {
        res.writeHead(200, {
          'Content-Type': 'image/png'
        });
      } else {
        res.writeHead(200, {
          'Content-Type': 'text/html'
        });
      }
    }
    return fs.readFile("." + req.url, function(err, content) {
      console.log("Someone is looking at me! Hello there!");
      if (err) {
        return fs.readFile("myCanvas.html", function(err, content) {
          res.write("" + content);
          return res.end();
        });
      } else {
        res.write("" + content);
        return res.end();
      }
    });
  };

  clientCallback = function(client) {
    var clientObj;
    clientObj = {
      id: client.id,
      health: 100,
      x: Math.random() * mapSize.width,
      y: Math.random() * mapSize.height,
      points: 0,
      width: 20,
      height: 20,
      bbRadius: 10,
      rotation: 0,
      kills: 0,
      deaths: 0,
      lastBullet: 0,
      velocity: {
        x: 0,
        y: 0
      },
      myKeys: [false, false, false, false],
      myBullets: []
    };
    clients.unshift(clientObj);
    client.broadcast.emit('clientJoined', clientObj);
    client.emit('clientList', clients);
    client.on('buttonPressedStart', function(evt) {
      if (evt === 32) {
        return clientObj.myKeys[4] = true;
      } else {
        return clientObj.myKeys[evt] = true;
      }
    });
    client.on('buttonPressedStop', function(evt) {
      if (evt === 32) {
        return clientObj.myKeys[4] = false;
      } else {
        return clientObj.myKeys[evt] = false;
      }
    });
    client.on('disconnect', function(evt) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = clients.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((clients[i] != null) && clients[i].id === client.id) {
          socket.sockets.emit('clientQuit', clients[i]);
          _results.push(clients.splice(i, 1));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    return client.on('clientStoppedFocus', function(evt) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = clientObj.myKeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (clientObj.myKeys.length < 1) {
          break;
        }
        clientObj.myKeys[i] = false;
        _results.push(console.log("PIE"));
      }
      return _results;
    });
  };

  radsToDegrees = function(rads) {
    return (rads * 180) / Math.PI;
  };

  handleControls = function() {
    var bullet, clientObj, maxVel, totalVel, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = clients.length; _i < _len; _i++) {
      clientObj = clients[_i];
      if (clientObj.myKeys[0]) {
        clientObj.rotation -= Math.PI * (tickRate / 1000);
        socket.sockets.emit('clientMoved', clientObj);
      }
      if (clientObj.myKeys[2]) {
        clientObj.rotation += Math.PI * (tickRate / 1000);
        socket.sockets.emit('clientMoved', clientObj);
      }
      if (clientObj.myKeys[1]) {
        clientObj.velocity.x += 5 * Math.cos(clientObj.rotation);
        clientObj.velocity.y += 5 * Math.sin(clientObj.rotation);
      }
      totalVel = Math.sqrt(Math.pow(clientObj.velocity.x, 2) + Math.pow(clientObj.velocity.y, 2));
      maxVel = 200;
      if (totalVel > maxVel) {
        clientObj.velocity.x *= maxVel / totalVel;
        clientObj.velocity.y *= maxVel / totalVel;
      }
      if (clientObj.myKeys[4] && (clientObj.lastBullet > 0.25)) {
        bullet = {
          x: clientObj.x,
          y: clientObj.y,
          width: 3,
          height: 3,
          bbRadius: 1,
          damage: 20,
          age: 0,
          velocity: {
            x: clientObj.velocity.x + (500 * Math.cos(clientObj.rotation)),
            y: clientObj.velocity.y + (500 * Math.sin(clientObj.rotation))
          }
        };
        clientObj.lastBullet = 0;
        _results.push(clientObj.myBullets.push(bullet));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  /*
      if clientObj.myKeys[3]
        clientObj.velocity.x -= Math.cos radsToDegrees(clientObj.rotation)
        clientObj.velocity.y -= Math.sin radsToDegrees(clientObj.rotation)
  */


  updatePhysics = function() {
    var asteroidObj, bullet, clientObj, currBullets, i, _i, _j, _k, _len, _len1, _ref, _results;
    _results = [];
    for (_i = 0, _len = clients.length; _i < _len; _i++) {
      clientObj = clients[_i];
      addVelocity(clientObj);
      stayOnMap(clientObj);
      currBullets = clientObj.myBullets.length;
      clientObj.lastBullet += tickRate / 1000;
      for (i = _j = 0, _ref = clientObj.myBullets.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        bullet = clientObj.myBullets[i];
        if (bullet == null) {
          break;
        }
        addVelocity(bullet);
        bullet.age += tickRate / 1000;
        stayOnMap(bullet);
        if (bullet.age > 1.5) {
          clientObj.myBullets.splice(i, 1);
        }
      }
      if (currBullets > 0) {
        socket.sockets.emit('bulletsUpdated', clientObj);
      }
      if (clientObj.velocity.x !== 0 || clientObj.velocity.y !== 0) {
        socket.sockets.emit('clientMoved', clientObj);
      }
      if (asteroids.length > 0) {
        for (_k = 0, _len1 = asteroids.length; _k < _len1; _k++) {
          asteroidObj = asteroids[_k];
          addVelocity(asteroidObj);
          stayOnMap(asteroidObj);
        }
        _results.push(socket.sockets.emit('asteroidUpdate', asteroids));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  stayOnMap = function(obj) {
    if (obj.x < 0) {
      obj.x += mapSize.width;
    }
    if (obj.x > mapSize.width) {
      obj.x -= mapSize.width;
    }
    if (obj.y < 0) {
      obj.y += mapSize.height;
    }
    if (obj.y > mapSize.height) {
      return obj.y -= mapSize.height;
    }
  };

  addVelocity = function(obj) {
    obj.x += (tickRate / 1000) * obj.velocity.x;
    return obj.y += (tickRate / 1000) * obj.velocity.y;
  };

  clientDied = function(clientObj) {
    clientObj.health = 100;
    clientObj.x = Math.random() * mapSize.width;
    clientObj.y = Math.random() * mapSize.height;
    clientObj.points = Math.round(clientObj.points / 2);
    clientObj.deaths++;
    return socket.sockets.emit('clientDied', clientObj);
  };

  isColliding = function(obj1, obj2) {
    var distance_total, distance_x, distance_y;
    if (!((obj1 != null) && (obj2 != null))) {
      return false;
    }
    if ((obj1.bbRadius != null) && (obj2.bbRadius != null)) {
      distance_x = obj2.x - obj1.x;
      distance_y = obj2.y - obj1.y;
      distance_total = Math.sqrt(Math.pow(distance_x, 2) + Math.pow(distance_y, 2));
      return obj1.bbRadius + obj2.bbRadius > distance_total;
    }
  };

  collisionDetection = function() {
    var asteroidObj, bullet, clientObj, didHit, h, i, shooterClient, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _results;
    _results = [];
    for (_i = 0, _len = clients.length; _i < _len; _i++) {
      shooterClient = clients[_i];
      for (i = _j = 0, _ref = shooterClient.myBullets.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        if (shooterClient.myBullets.length < 1) {
          break;
        }
        bullet = shooterClient.myBullets[i];
        didHit = false;
        for (_k = 0, _len1 = clients.length; _k < _len1; _k++) {
          clientObj = clients[_k];
          if (shooterClient.id === clientObj.id) {
            continue;
          }
          if (isColliding(clientObj, bullet)) {
            clientObj.health -= bullet.damage;
            didHit = true;
            if (clientObj.health <= 0) {
              shooterClient.points += Math.round(clientObj.points / 4);
              shooterClient.kills++;
              socket.sockets.emit('bulletHit', shooterClient);
              clientDied(clientObj);
            } else {
              shooterClient.points += 50;
              socket.sockets.emit('bulletHit', shooterClient);
              socket.sockets.emit('bulletHurt', clientObj);
            }
          }
        }
        for (h = _l = 0, _ref1 = asteroids.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; h = 0 <= _ref1 ? ++_l : --_l) {
          if (asteroids.length < 1) {
            break;
          }
          asteroidObj = asteroids[h];
          if (isColliding(asteroidObj, bullet)) {
            didHit = true;
            shooterClient.points += Math.round(asteroidObj.bbRadius);
            breakAsteroid(h);
          }
        }
        if (didHit) {
          shooterClient.myBullets.splice(i, 1);
        }
      }
      _results.push((function() {
        var _m, _ref2, _results1;
        _results1 = [];
        for (h = _m = 0, _ref2 = asteroids.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; h = 0 <= _ref2 ? ++_m : --_m) {
          if (asteroids.length < 1) {
            break;
          }
          asteroidObj = asteroids[h];
          if (isColliding(shooterClient, asteroidObj)) {
            breakAsteroid(asteroidObj);
            shooterClient.health -= asteroidObj.bbRadius;
            if (shooterClient.health <= 0) {
              clientDied(shooterClient);
            }
            breakAsteroid(h);
            _results1.push(socket.sockets.emit('asteroidHurt', shooterClient));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  newAsteroid = function(x, y, radius) {
    var asteroid;
    if (x == null) {
      x = Math.random() * mapSize.width;
    }
    if (y == null) {
      y = Math.random() * mapSize.height;
    }
    if (radius == null) {
      radius = (Math.random() * 10) + 30;
    }
    asteroid = {
      x: x,
      y: y,
      id: asteroids.length,
      bbRadius: radius,
      velocity: {
        x: (Math.random() * 200) - 100,
        y: (Math.random() * 200) - 100
      }
    };
    return asteroids.push(asteroid);
  };

  breakAsteroid = function(asteroidIndex) {
    var asteroidObj;
    if (asteroids[asteroidIndex] == null) {
      return;
    }
    asteroidObj = asteroids[asteroidIndex];
    if (asteroidObj.bbRadius > 15) {
      newAsteroid(asteroidObj.x, asteroidObj.y, asteroidObj.bbRadius / 2);
      newAsteroid(asteroidObj.x, asteroidObj.y, asteroidObj.bbRadius / 2);
    }
    return asteroids.splice(asteroidIndex, 1);
  };

  updateAsteroids = function() {
    var asteroidObj, totalSize, _i, _len;
    totalSize = 0;
    for (_i = 0, _len = asteroids.length; _i < _len; _i++) {
      asteroidObj = asteroids[_i];
      totalSize += asteroidObj.bbRadius;
    }
    if (totalSize < 200) {
      return newAsteroid();
    }
  };

  updateStats = function() {
    var clientObj, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = clients.length; _i < _len; _i++) {
      clientObj = clients[_i];
      if (clientObj.health < 100) {
        _results.push(clientObj.health += 0.05);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  eachFrame = function() {
    updateStats();
    handleControls();
    updateAsteroids();
    updatePhysics();
    return collisionDetection();
  };

  server = http.createServer(serverCallback).listen(8080);

  socket = io.listen(server);

  socket.on('connection', clientCallback);

  socket.set('log level', 1);

  setInterval(eachFrame, tickRate);

}).call(this);
